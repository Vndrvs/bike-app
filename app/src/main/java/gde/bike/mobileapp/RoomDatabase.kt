package gde.bike.mobileapp

import androidx.room.Database
import androidx.room.Entity
import androidx.room.PrimaryKey
import androidx.room.Room
import androidx.room.RoomDatabase
import android.content.Context
import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query

// itt hozzuk létre a bike táblát és az adatbázist
// a bike tábla recordjai lesznek a JSON-ból kapott adatok
@Entity("Bikes")
class Bike(
    // nem szükséges autogenerated, mivel a JSON inputunk már tartalmaz használható ID-ket
    @PrimaryKey val id: Long,
    val brand: String,
    val model: String,
    val price: Double,
    val category: String,
    val description: String,
    val availability: String
)

@Database(
    entities = [Bike::class],
    // létrehozáskor mindenképpen szükséges a verziószám megadása az adatbázis sémához
    version = 1
)

abstract class AppDatabase: RoomDatabase() {
    companion object{
        fun buildDb(context: Context) = Room.databaseBuilder(context, AppDatabase::class.java, "bike.db")
            // .allowMainThreadQueries() kivételesen azért kell, hogy időigényes query ne akassza meg a threadet
            // ez alapesetben bad practice(KERÜLENDŐ), csak a példa erejéig alkalmazzuk, hogy most ne kelljen multithreadelni
            .allowMainThreadQueries()
            // pl. ha az adatok más forrásból cachelve érkeznek a programba és egyszerűen elérhetőek,
            // akkor használható a fallbackToDestructiveMigration()
            .fallbackToDestructiveMigration(true)
            .build()
    }

    abstract fun bikeDao(): BikeDao
}

@Dao
interface BikeDao {

    @Insert(onConflict = OnConflictStrategy.REPLACE) // mit csináljon a program, ha már talál ilyen recordot a táblában
    fun insert(bike: List<Bike>)

    @Query("SELECT * FROM bikes") // teljes bicikli lista lekérése
    fun getAllBikes(): List<Bike>

    @Query("SELECT * FROM bikes WHERE id = :id") // konkrét bicikli lekérése, ID használatával
    fun getBikeById(id: Long): Bike?
}